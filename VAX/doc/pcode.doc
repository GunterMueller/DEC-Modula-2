.de Op
.sp
.RT
.if !\\n(IP .nr IP +1
.ne 3
.in 0.5i
.ta 2i
.ti -0.5i
\\$1 \\$2	\\$3
.br
.na
..
.nr PO 1i
.po 1i
.TL
A Terse Description of P-code
.AU
Michael L. Powell
.NH 1
The Basic Idea
.LP
P-code appears to be machine instructions for a stack computer.
It is not executed as such, however, but is translated into machine
instructions for your favorite computer.
Thus, you will find in P-code some information to aid that translation,
which would not be necessary if the instructions were simply to be executed.
The "P-code translator", as it is called, is expected to do a certain amount of
peephole optimization, especially constant folding in address calculation.
Thus, although some higher level optimization may be done,
the P-code generated by the front end will not be optimal.
.LP
There are four classes of P-code instructions:
those that move values between the stack and memory,
those that operate on values on the stack,
those that control the flow of execution,
and pseudo-instructions for storage allocation and other functions.
The stack will be empty at procedure entry, at labels, and between statements.
Several mechanisms exist for storing values that must span these boundaries.
.LP
This dialect of P-code is only loosely affiliated with other dialects that
exist.
No compatibility is claimed.
.LP
This document will discuss, in order, the general format of P-code instructions
and P-code programs,
the use and layout of memory,
and the function of individual operations by class.
.NH 1
P-code programs
.LP
The first statement of a P-code program is a
.I bgn
opcode.
After the bgn comes the
.I com
instructions that declare global static storage.
Then there are one or more P-code procedures.
The last statement is an
.I end
opcode.
In addition,
.I sym
instructions, which provide symbol table information for the debugger and the
intermodule checker,
may appear throughout the program.
Note: If DBX debugging information is generated (-g option),
the bgn will be preceded by a
.I sym
and a
.I lab.
.LP
A P-code procedure starts with an
.I ent
opcode and ends with an
.I exi
opcode.
There must also be a
.I def
opcode between the
.I ent
and the
.I exi.
All executable statements must be inside some P-code procedure.
.LP
P-code instructions have a fixed format,
which allows faster parsing.
There is one P-code instruction per line.
A line starting with a # is a comment.
In the following, a
.I gap
is a sequence of one or more tab or space characters.
If a line does not start with a gap, the characters up to the first
gap is a label.
Labels, which can occur only on
.I bgn,
.I lab,
and
.I ent
opcodes,
can contains letters, digits or _ characters.
Following the first gap is the three character P-code opcode.
If there are operands on the instruction, there is another gap
after the P-code opcode followed by the list of operands separated by commas.
There should be no gaps between the operands.
.DS
.ta 9 17 25 33
# P-code instruction with label
l10001	ent	P,0,2,102,1,5,100,-1
#	blank lines are not allowed
# P-code instruction without label
	lod	i,32,0,t,0,102
.DE
.LP
P-code labels and operands may be quite long
(the current VAX translator allows up to 5,000 characters per operand).
Labels must be long enough to handle qualified names;
operands must be long enough to handle set and string constants
and symbol table information.
There is a small maximum number of operands (currently 8).
A particular opcode usually, but not always, has the same number of operands.
.LP
Operands may be characters, words, numbers, etc.
Operands may contain any printable character except comma and linefeed.
String operands are quoted with double quotes (");
within a string, a backslash (\e) must precede a double quote or backslash.
Non-printing characters (outside the range of space (40 octal)
to tilde (176 octal)) may be represented by a backslash followed by three
octal digits, e.g., linefeed is "\e012".
.LP
If you have the DECWRL Modula-2 compiler, you can generate a set of P-code
for a program by compiling with the -P option.
.NH 1
P-code memory
.LP
There are several kinds of memory visible at the level of P-code instructions.
These include the stack, stack save registers,
global variables, and local (procedure) variables.
The P-code translator may use additional memory locations to implement
various facilities, for example, the display.
However, since they are implementation dependent and not visible to the
P-code program, they will not be discussed here.
.NH 2
The Stack
.LP
The stack is used for evaluating expressions.
For example, the P-code instructions to compute the statement
.DS
a := b + c
.DE
would be something like
.DS
load b
load c
add
store a
.DE
.LP
Procedure arguments are also loaded onto the stack.
The stack is in theory infinite but in practice 20 elements have been
sufficient.
Values to be operated on are always loaded onto the stack first.
A P-code operation pops its operands off the stack and pushes its
result onto it.
The result should then be stored in memory, removing it from the stack.
.LP
Stack values are usually mapped into registers by the P-code translator.
Since the P-code translator runs in one pass,
there are some P-code programs that are impractical.
In general, values should not be left on the stack (or in the stack save
registers) across branches and labels.
In fact, for most languages, the stack will be empty between statements.
.LP
There are no real limits to how large an element may be loaded onto the
stack.
The semantics of most languages restrict the size of most values
to a word or two.
Some languages permit larger values, for example, set expressions, and these
must be handled as well.
.NH 2
Stack save registers
.LP
There are about a dozen "registers" in the P-code machine.
These registers are used to save values that are used more than once in
an expression or to provide storage with a non-stack discipline during
expression evaluation.
For example, to evaluate a conditional expression, one might save a value in
the same stack save register in the then and else parts, and use the register
as the result.
.LP
The stack registers are designed to be just like the stack elements, and are
not simply a word of storage.
Values are moved or copied between the stack and the save registers using the
.I sav
and
.I use
P-code instructions.
The registers are identified by small integers.
.NH 2
Global and local variables
.LP
Global variables are statically allocated and accessible in separately compiled
modules.
Storage is defined with the
.I com
P-code instruction, which specifies the name and the size of the storage and
establishes a local index to be used for references to the variable.
.LP
Local variables are allocated on entry to the procedure, usually on a runtime
stack.
Local variables do not have individual identities, but are grouped by
memory class into an activation record,
and referenced by offset relative to the start of the particular memory class.
The amount of storage of each class is specified on the
.I def
instruction.
.LP
Local variables may be accessed by the procedure that defines them or by nested
procedures that are called while the procedure is active.
A display or static links must be maintained to allow uplevel accesses.
.LP
There are three instructions that refer to global variables:
.TS
l l l.
ldo	T,S,M,O,N	Load variable onto stack
sro	T,S,M,O,N	Store top of stack into variable
lao	S,M,O,N	Load address of variable onto stack
.TE
.LP
There are four instructions that refer to local variables:
.TS
l l l.
lod	T,S,D,M,O,N	Load variable onto stack
str	T,S,D,M,O,N	Store top of stack into variable
stn	T,S,D,M,O,N	Copy top of stack into variable
lda	S,D,M,O,N	Load address of variable onto stack
.TE
.LP
The last three operands of each memory reference instruction is an address
triple.
The first operand (M) of the triple is a letter indicating the memory class;
the second (O), an integer bit offset into that class of memory;
the third (N), a block number.
For global variables, the memory class is always
.I c,
the offset is from the beginning of the variable,
and the block number is the number on the
.I com
instruction defining the variable.
For local variables, the memory class may be
.I p,
.I m,
.I b,
or
.I t,
the offset is from the beginning of that memory class,
and the block number is the number on the
.I ent
instruction of the procedure containing the variable.
.LP
Memory classes allow the P-code translator to distinguish variables
according to important characteristics.
.ne 8
.TS
l l
c l.
Class	Usage
c	Global/static variables
p	Parameter list memory
m	General local memory
t	Faster local memory
b	Faster local memory for addresses
.TE
.LP
Memory class b is like t and is useful for machines with address registers.
Offsets in p memory are relative to the start of the parameter list.
Usually, t memory is placed so that it has shorter offsets from the
frame pointer than m.
The front end will allocate loop indices and other single-word variables
to t memory in the hope that it can be accessed faster than m memory.
It is also possible for some of t memory to be allocated to registers.
.LP
The display level (D) in the local variable instructions is the display
level relative to the current procedure (0 = local, 1 = enclosing procedure,
etc.).
.LP
The first two operands of the load and store instructions are the data type (T)
and size (S) in bits of the variable.
The load address instruction specifies the size but not the type of the area
addressed.
The following are the data types specified in these and other instructions.
.TS
l l
c l.
Type	Data type
a	address
b	boolean
c	character
i	signed integer
j	unsigned integer
k	positive integer
p	procedure value
q	untyped
r	real
R	double word real
s	character string
S	set
.TE
.LP
Since both the sizes and the offsets of variables are specified in bits,
it is possible for the front end to directly refer to packed fields of
records, etc.
A particular P-code translator implementation will place restrictions on
the size and alignment requirements of variables and addresses.
For example, although address constants and offsets are specified in
bits, a particular implementation may require them to be multiples of
bytes.
.NH 1
P-code instructions
.LP
In this section, we give a brief description of the P-code instructions.
The following is an example instruction description: 
.Op pcd O1,O2 T1,T2
S0 := f(Si).
.LP
In the example, pcd is the P-code opcode;
O1, O2 are the operands on the P-code instruction;
T1, T2 are the types of values the instruction works on.
Except as noted, the same conventions are used as in the preceding section.
In the description of the operation,
S0 means the top of the stack,
S1 means the next to top of the stack, etc.
The assignment
.DS
S0 := f(Si)
.DE
means the stack elements Si referenced in f are popped off the stack and
resulting value placed on the top of the stack.
If no assignment is made to S0, then no new value is pushed on the stack.
The expression [x] means the memory location addressed by x.
Note:
An opcode that works for data type
.I i
also works for data types
.I j
and
.I k.
An opcode that works for data type
.I r
also works for data type
.I R.
.NH 2
Memory reference operations
.LP
The following instructions move values between the stack and memory:
.Op ind T,S all
S0 := [S0].
.Op lao S,M,O,N all
S0 := address of static variable specified by M,O,N.
.Op lda S,D,M,O,N all
S0 := address of procedure variable specified by D,M,O,N.
.Op ldo T,S,M,O,N all
S0 := value of static variable specified by M,O,N.
.Op lod T,S,D,M,O,N all
S0 := value of procedure variable specified by D,M,O,N.
.Op sro T,S,M,O,N all
Static variable specified by M,O,N := S0.
.Op stn T,S,D,M,O,N all
Local variable specified by D,M,O,N := S0, leave S0 on stack.
.Op sto T,S all
[S0] := S1, pop both S0 and S1.
.Op str T,S,D,M,O,N all
Local variable specified by D,M,O,N := S0.
.NH 2
Stack operations
.LP
The following instructions manipulate values on the stack:
.Op adr
This instruction is a cheap hack to allow functions to return arrays and
records which can then be indexed or selected.  It indicates that the value on
top of the stack should be considered to be the address of a data structure.
.Op abs T i,r
S0 := absolute value of S0.
.Op add T,S a,c,i,r
S0 := S0 + S1.
.Op ad2 T,S a,c,i,r
[S1] := [S1] + S0
.Op and T,S b
S0 := S0 boolean and S1.
.Op bit X i
X is a letter specifying the bitwise function to be performed.
.TS
l l
c l.
X	S0 :=
a	S0 bitwise and S1
o	S0 bitwise or S1
n	bitwise complement S0
x	S0 bitwise exclusive or S1
l	S1 shifted left logically S0 bits
r	S1 shifted right logically S0 bits
e	extract S0 bits of S2 starting at S1
i	insert S3 into S0 starting at S2 for S1 bits
.TE
.Op cap "" c
S0 := capitalize S0; if S0 is a lower case letter, make it upper case.
.Op chr "" i
S0 := character type S0; convert type from integer to character.
.Op dec T,V i,a
S0 := S0 - V; V is in bits for addresses.
.Op dif T,S S
S0 := S1 set subtract S0.
.Op div T,S i,r
S0 := S1 / S0.
.Op dv2 T,S i,r
[S1] := [S1] / S0.
.Op equ T,S a,b,c,i,q,r,s,S
S0 := boolean result of S1 = S0.
.Op flt T	r,R
S0 := convert to float S0;
if T is r, flt converts longreal or integer to real;
if T is R, flt converts real or integer to longreal.
.Op geq T,S a,b,c,i,q,r,s,S
S0 := boolean result of S1 >= S0.
.Op grt T,S a,b,c,i,q,r,s,S
S0 := boolean result of S1 > S0.
.Op inc T,V i,a
S0 := S0 + V; V is in bits for addresses.
.Op inn T,S S
S0 := boolean result of S0 in set S1.
.Op int T,S S
S0 := S1 set intersection S0;
.Op ior T,S b
S0 := S1 boolean or S0.
.Op lca T,S,value a,b,c,i,p,r,s,S
S0 := address of constant specified by T,S,value.
.TS
l l l
c l l.
T	Kind	Value
a	address	integer; in bits
b	boolean	integer; 1=true, 0=false
c	char	"x"
i	integer	integer value
j	cardinal	cardinal value
n	address	omitted, nil pointer
p	procedure	procedure name
r	real	real value
R	longreal	longreal value
s	string	"xxx"; null padded to size
S	set	n,bbbb; n=number of b's, b=0/1
.TE
.Op ldc T,S,value a,b,c,i,p,r,s,S
S0 := value of constant specified by T,S,value.
See lca for constant types and values.
.Op leq T,S a,b,c,i,q,r,s,S
S0 := boolean result of S1 <= S0.
.Op les T,S a,b,c,i,q,r,s,S
S0 := boolean result of S1 < S0.
.Op max T i,r
S0 := maximum of S1 and S0
.Op min T i,r
S0 := minimum of S1 and S0
.Op mod T,S i
S0 := S1 mod S0 (mod is modulus, not remainder).
.Op mp2 T,S a,i,r
[S1] := [S1] * S0.
.Op mup T,S a,i,r
S0 := S1 * S0.
.Op neg T,S a,i,r
S0 := - S0;
.Op neq T,S a,b,c,i,q,r,s,S
S0 := boolean result of S1 <> S0.
.Op not T,S b
S0 := boolean not S0.
.Op odd "" i
S0 := boolean result of S0 mod 2 = 1.
.Op ord T,S a,b,c,i
S0 := integer type S0; change type to integer.
.Op rnd T
SO := round(S0); round real or longreal to integer.
.Op sav N,X all
Save S0 in stack register N.
If X = c, the value is also left on the stack;
otherwise, it is discarded.
.TS
l l.
X	Operation
c	N is not in use, copy S0 into it.  This does not require that any data
	actually move; if S0 is simple enough, you can copy a description
        of S0 into N.  For example, the VAX doesn't copy S0 if it is a constant,
	or if S0 is stored in a register.
d	N is irrelevant.  Discard S0.  Use to pop the top element of the stack
m	N is not in use, move S0 into it
r	N is in use, store value of S0 into it
t	N is not in use, transfer S0 into it.  Even if S0 is simple, you should
	generate code to physically copy the data in S0.
.TE
.Op sb2 T,S a,c,i,r
[S1] := [S1] - S0.
.Op sdf T,S S
S0 := S1 symmetric set difference S0.
.Op set T,S,N S
Generate a set on the stack and unions it with the existing set.
If N = 1, S0 := the set contains only element S0.
If N = 2, S0 := the set contains elements S1 through S0 inclusive.
.Op sex T,S S
Remove element S0 from set [S1].
.Op sin T,S S
Add element S0 to set [S1].
.Op sml T,S S
S0 := index of smallest element in S0.
.Op sub T,S a,c,i,r
S0 := S1 - S0.
.Op trc T r
S0 := integer result of truncating S0.
.Op typ T,S all
S0 := change type and size of S0 as specified.
.Op uni T,S S
S0 := S1 set union S0.
.Op use N,X all
S0 := stack register N;
if X = c, the stack register retains the value;
otherwise, the stack register is discarded.
.TS
l l.
X	Operation
c	Copy value onto stack
m	Move value onto stack
d	Simply discard the stack register
.TE
.NH 2
Control instructions
.LP
The following instructions affect the control flow:
.Op cep T,S,N,name
Call external procedure name.
T and S describe the return value if name is a function;
T = P if name is a procedure.
N is the number of parameters passed to the procedure.
The parameters are SN-1,SN-2,...,S0.
.Op chk T,Values
Perform a runtime check, aborting the program if there is an error.
The check performed depends on the value of X as follows:
.RS
.IP a
Pointer validation.
Check that S0 is a valid pointer.
Leave S0 on the stack.
The check performed depends on the type of pointer:
.TS
l l
c l.
Values	Kind of pointer
m	Modula-2
p	Pascal
n	Check <> nil
.TE
.IP c
Case not found in case statement.
This instruction is generated as the default else if one is not specified for
a case statement.
.IP d
Dynamic array validation.
S0 points to a dynamic array; check its pointer.
Leave S0 on the stack.
The check depends on the type of pointer, as in pointer validation.
.IP o
Check open array subscript.
S1 is the subscript value, check that 0 <= S1 < S0.
Pop S0 off the stack.
.IP p
No return from function.
This instruction is generated at the end of a function that does not end with
a return statement.
.IP r
Check subrange value.
Values = T,N1,N2, where T is the type of value, N1 is the minimum legal value
and N2 is the maximum legal value.
Check that N1 <= S0 <= N2.
Leave S0 on the stack.
.IP s
Check normal subscript.
Like r with a different message.
.IP v
Check variant tag.
S0 is the address of a record.
Values = O,S,List.
O is the offset of the tag in bits from S0.
S is the size of the tag.
List is a list of values separated by semicolons.
If List starts with a ~, then the tag must not have any of the values.
Otherwise, the tag must have one of the values.
A value is either a single number or two numbers separated by a colon,
indicating a range of values.
.IP x
Check subarray former on open array.
S0 is the size of the whole array.
S1 is the starting subscript.
S2 is the number of elements to put in the subarray.
Check that 0 <= S2 <= S1+S2 <= S0.
Pop S0 and S1 off the stack.
.IP A
Assert statement failed.
S0 is a string.
Produce an error message including S0.
.RE
.Op cip T,S,N
Call indirect to a procedure.
S0 is the address of the procedure.
T and S describe the return value if the procedure is a function;
T = P if it is not.
N is the number of parameters passed to the procedure.
The parameters are SN,SN-1,...,S1.
.Op cjp L
Case jump.
Generate a jump table entry for label L.
Used to generate a table for the XJP instruction.
.Op cup T,S,N,name
Call external procedure name.
T and S describe the return value if name is a function;
T = P if name is a procedure.
N is the number of parameters passed to the procedure.
The parameters are SN-1,SN-2,...,S0.
.Op ent T,S,L,N,P,Line,F,R
Procedure entry.
The ent instruction has a label, which is the name of the procedure.
T and S are the type and size of the return value if the procedure is a
function.
T = P if the procedure is not a function.
L is the nesting level of the procedure; the main program and global procedures
are level 1.
N is the block number of the procedure.
P is the number of parameters to the procedure.
Line is the line number of the start of the procedure.
F is a set of flags indicating things about the procedure.
The first character is 1 if the procedure contains no nested procedures.
The second character is 1 if the internal calling sequence is used for this
procedure.
R is the number of words of t memory (starting at offset 0)
that may be safely allocated to registers.
.Op fjp L
Jump if false.
If S0 is false, jump to label L.
S0 is popped off the stack.
.Op for T,S,L
For jump.
S0 = limit value, S1 = increment, S2 = address of index variable.
[S2] := [S2] + S1; if (S1 > 0 and [S2] <= S0) or (S1 < 0 and [S2] >= S0),
jump to L.
Pop S0, S1, and S2.
.Op lab
The lab instruction has a label.
Define an instruction label.
.Op ljp L,D,N
Long (out-of-block) jump (Pascal only).
Jumps to a label in another procedure.  L is the destination
label name, D is the distance between the current nesting level and the target
nesting level, and N is the block number of the destination procedure.
The destination procedure must have executed an sst (Save state) opcode for
ljp to work
.Op mst N
Mark the stack.
This instruction marks the beginning of a procedure call.  N is the number of
arguments (words) passed to the procedure.
It is followed by the parameter expressions, par instructions, and finally
the call instruction.
.Op par N
Push argument N.  Move S0 into parameter argument N.  This may load a register
with S0, push S0 onto the argument stack, or do whatever your calling
conventions dicate.
.Op ret T,S
Return from a procedure.
If the procedure is a function, T and S are the type and size of the return
value, which is S0.
If the procedure is not a function, T = P.
.Op rst
Restore state (Pascal only).
If this procedure has a label which is the destination of an ljp (Long jump),
this is the first instruction at the destination label.  This instruction
restores whatever state was saved with the sst (Save state) instruction.
.Op sst
Save state (Pascal only).
If this procedure has a label which is the destination of an ljp (Long jump)
instruction, it includes an sst opcode as part of the procedure
initialization code.  This instruction saves the current display and any other
information needed to restore state if an ljp instructions jumps into the
procedure.
.Op tjp L
Jump if true.
If S0 is true, jump to label L.
S0 is popped off the stack.
.Op ujp L
Jump unconditionally.
Jump to label L.
.Op xjp T,E,L,U
Indexed (case) jump.
Select a destination based on a value.
If S0 is not a value between L and U inclusive, jump to the label E.
Otherwise, T is a label of a set of cjp instructions.
Select the entry number S0 - L and jump to its destination.
.NH 2
Pseudo instructions
.LP
The following pseudo-instructions allocate memory and perform other
useful functions:
.Op bgn Language,N,F
The bgn instruction has a label, which is the name of the module.
The label can be used to make unique global names in the P-code translator.
The Language operand indicates the compiler that generated the file.
N is the procedure number of the main program, if it is in this compilation;
otherwise, 0.
Initialization code will be inserted at the beginning of that program.
F is a set of flags indicating options on the compile.
If the first character is 1, statement counting will be done for this module.
If the second character is 1, gprof profiling will be done for this module.
.Op com N,Name,S,T
Define global/static storage.
N is the block number assigned to the variable used
in load and store instructions.
Name is the global name to be used for the variable.
S is the size of the variable.
T is the type of storage to allocate as follows:
.RS
.IP d
External storage is defined in another module.  Equivalent to .comm
on Unix systems.
.IP e
External storage is defined here.  Equivalent to .globl on
Unix systems.
.IP i
External storage and initialization is defined here.  Equivalent
to .globl on Unix systems, and see the ini opcode for initialization details.
.IP I
Private storage and initialization is defined here.  
.RE
.Op cts X,Values
Do statement counting.
The function performed depends on the value of X as follows:
.RS
.IP i
Initialize this module.
.IP d
Define the counter table for this module.
Values = N,Name.
N is the number of counters in this module.
Name is the file name for this module.
.IP c
Increment statement counter.
Values = N,M.
N is the statement counter.
M is the line number corresponding to the counter.
.RE
.Op dbg 
Dump p-code internal state.
This opcode is used only for debugging p-code translators, not for debugging
programs.
.Op def SP,ST,SM,N,Name
Define the size of procedure storage.
SP is the size of p memory (parameters).
ST is the size of t memory.
SM is the size of m memory.
N is the block number of the procedure.
Name is the name of the procedure.
.Op ini O,S,T,value
Initialize a portion of a global variable.
There may be several ini opcodes used to
initialize a single variable if it has a structured type.  O is the bit
offset into the variables storage.  S is the size in bits.  T is the type of
data, and value is a constant the described storage should be initialized to.
Initialization for a variable is finished when the bit offset O is -1.
.Op sac
Allocate memory on the stack and copy.
S1 is the address of a pointer that points to the value to be copied, and that
will be set to point to the new area.
S0 is the size of the area as an address constant or expression.
The sac instruction is useful for copying value parameters, especially
variable-length ones.
.Op sal
Allocate memory on the stack.
S1 is the address of a pointer that is set to the beginning of the new area.
S0 is the size of the area as an address constant or expression.
The sal instruction is useful for allocating variable size local variables.
.Op sym X,Values
Generate debugger symbol table information.
The sym instruction operands are designed around DBX.
The value of X determines the treatment of the operands.
The Values are used to generate the appropriate .stabd or .stabs assembler
directive.
.NH 1
Some traditions
.LP
Although it may be tempting to think of P-code as a well-defined interface,
in fact, there are few hard and fast rules.
For example, the operands on bgn and ent instructions often change as necessary
for a particular implementation.
Memory classes can be added to model the particular kinds of registers and
data types on a particular machine.
.LP
A P-code translator should be able to operate in one pass, generating assembly
language as it parses P-code.
By generating assembly language, the P-code translator can avoid problems caused
by forward references.
Jump labels and activation record sizes are generally used with forward
references. 
.LP
The front end usually knows for what kind of machine it is generating code.
Although sizes and offsets are expressed in bits, a particular implementation
may require some or all data types to have particular sizes or alignments.
It may also be necessary to align address values on particular boundaries.
Since the front end allocates storage, it is responsible for rounding up
sizes and aligning data types as required.
.LP
